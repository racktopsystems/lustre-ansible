---
# This fact gathering gives us version information for hiavd as well as
# whether or not it has already been configured, which we depend upon
# during generation of the config file. We do this because we
# want to avoid re-creation of the config file and critically the state
# file due to content mismatch which will necessarily occur as the state
# file evolves over time.
- name: Gather hiavd program facts
  hiavd_facts:

- name: HA service setup
  vars:
    ip_address: "{{inventory_hostname}}"
    first_ha_node: "{{hostvars[ip_address].first_ha_node}}"
    peer_ip_address: "{{hostvars[ip_address].ha_peer_ipaddr}}"
    first_node_uuid: "{{ ansible_product_uuid if first_ha_node
      else hostvars[peer_ip_address].ansible_product_uuid }}"
    second_node_uuid: "{{ ansible_product_uuid if not first_ha_node else hostvars[peer_ip_address].ansible_product_uuid }}"
    first_node_name: "{{ ansible_hostname if first_ha_node else hostvars[peer_ip_address].ansible_hostname }}"
    second_node_name: "{{ ansible_hostname if not first_ha_node else hostvars[peer_ip_address].ansible_hostname }}"
    first_node_ipmi_ip_address: "{{ ipmi_ip_address if first_ha_node
      else hostvars[peer_ip_address]['ipmi_ip_address'] }}"
    second_node_ipmi_ip_address: "{{ ipmi_ip_address if not first_ha_node
      else hostvars[peer_ip_address]['ipmi_ip_address'] }}"
    first_node_public_ip_address:
      "{{ ansible_default_ipv4.address if first_ha_node
      else hostvars[peer_ip_address]['ansible_default_ipv4']['address'] }}"
    second_node_public_ip_address:
      "{{ ansible_default_ipv4.address if not first_ha_node
      else hostvars[peer_ip_address]['ansible_default_ipv4']['address'] }}"
    first_node_private_ip_address: "{{ hb_iface_ipaddr if first_ha_node
      else hostvars[peer_ip_address]['hb_iface_ipaddr'] }}"
    second_node_private_ip_address: "{{ hb_iface_ipaddr if not first_ha_node
      else hostvars[peer_ip_address]['hb_iface_ipaddr'] }}"

    witness_uuid: "{{ hostvars[groups['cluster_witness'][0]].ansible_product_uuid }}"
    witness_name: "{{ hostvars[groups['cluster_witness'][0]].ansible_hostname }}"
    witness_public_ip_address: "{{ hostvars[groups['cluster_witness'][0]].ansible_default_ipv4.address }}"

  # In this block some tasks have a `when` conditional eventhough these tasks
  # render a template, which seems like an odd thing to do, given the template
  # should be rendered identically each and every time.
  # We do this because even though we use a template to create the initial
  # state, these files will eventually change and will therefore be replaced by
  # Ansible because the rendered template version will not be a match to the
  # file on disk. Thus we have to have another way to detect whether this play
  # should make changes. Serialized state file changes each time there are
  # changes to cluster configuration, while `hiavd` configuration file will
  # change each time version of the code changes.
  block:
    - name: Generate cluster-wide guid
      xor_uuid:
        uuid1: "{{ first_node_uuid }}"
        uuid2: "{{ second_node_uuid }}"
      register: reg_cluster_guid

    - name: Generate {{ bsr_config_file }}
      ansible.builtin.template:
        dest: "{{ bsr_config_file }}"
        src: templates/{{ bsr_config_file }}.j2

    - name: Generate {{ identifiers_file }}
      ansible.builtin.copy:
        content: '{"ClusterId": {{ reg_cluster_guid.guid_hash }}, "ClusterGuid": "{{ reg_cluster_guid.guid }}"}'
        dest: "{{ identifiers_file }}"

    - name: Generate {{ hiavd_config_file }}
      ansible.builtin.template:
        dest: "{{ hiavd_config_file }}"
        src: templates/{{ hiavd_config_file }}.j2

    # After initial generation this state file will be mutated by hiavd.
    - name: Generate {{ hiavd_state_file }}
      ansible.builtin.template:
        dest: "{{ hiavd_state_file }}"
        src: templates/{{ hiavd_state_file }}.j2
      when:
        - ansible_facts.hiavd.new_configuration
        - hiavd_force_config_recreation

  notify: Restart hiavd service
