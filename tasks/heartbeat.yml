---
- name: Setup HA heartbeat ({{ hb_iface_desired_name }}) interface
  vars:
    # Boolean value indicating whether 'ansible_<hb_iface_desired_name>' key is
    # present in the host's inventory. If present, it means the rule must
    # already be in place, thus don't try to create it, because it is going to
    # fail, due to the interface having been renamed already to our desired
    # heartbeat interface name.
    hb_iface_in_inventory: "{{ 'ansible_' + hb_iface_desired_name in hostvars[inventory_hostname] }}"
    kernel_iface_name: '{{ vm_os_assigned_hb_iface_name if ansible_virtualization_role == "guest" else phys_os_assigned_hb_iface_name }}'
    mac_address: '{{hostvars[inventory_hostname]["ansible_" + kernel_iface_name].macaddress}}'
    final_iface_name: "{{ hb_iface_desired_name }}"

  block:
    # If the network configuration file for the hb0 interface already exists,
    # we are just going to make sure that it is correct. We do this by reading
    # in the file and extracting bits we care about, the UUID namely and then
    # we generate a new file with settings we expect, injecting bits we read in
    # previously. Otherwise we just create a new file and generate bits like
    # the UUID.
    - name: Make sure that the {{ hb_iface_desired_name }} interface file exists
      ansible.builtin.stat:
        path: "{{ netconfig_dir }}/ifcfg-{{ hb_iface_desired_name }}"
      register: hb_conf_file_result

    - name: Read in contents of the {{hb_iface_desired_name}} interface file
      ansible.builtin.slurp:
        src: "{{ netconfig_dir }}/ifcfg-{{ hb_iface_desired_name }}"
      register: reg_iface_file
      when: hb_conf_file_result.stat.exists

    - name: Convert {{ hb_iface_desired_name }} interface file into a dict
      vars:
        text: "{{reg_iface_file.content | b64decode | trim }}"
        # This is absolutely horrible, and we should find a better way.
        pairs: "[{% for line in text.split('\n') %}{{line.split('=')}},{% endfor %}]"
      set_fact:
        cf_iface_file: "{{ dict(pairs) }}"
      when: hb_conf_file_result.stat.exists

    - name: Create facts for {{ hb_iface_desired_name }} interface file
      vars:
        uuid: "{{ ansible_product_uuid | to_uuid }}"
      set_fact:
        cf_iface_file: "{{ dict(UUID=uuid) }}"
      when: not hb_conf_file_result.stat.exists

    - name: Create new interface file for the {{ hb_iface_desired_name }} heartbeat network interface
      ansible.builtin.copy:
        dest: "{{ netconfig_dir }}/ifcfg-{{ hb_iface_desired_name }}"
        content: |
          TYPE=Ethernet
          PROXY_METHOD=none
          BROWSER_ONLY=no
          BOOTPROTO=none
          DEFROUTE=yes
          IPV4_FAILURE_FATAL=no
          IPV6INIT=yes
          IPV6_AUTOCONF=yes
          IPV6_DEFROUTE=yes
          IPV6_FAILURE_FATAL=no
          IPV6_ADDR_GEN_MODE=default
          NAME={{ hb_iface_desired_name }}
          UUID={{ cf_iface_file['UUID'] }}
          DEVICE={{ hb_iface_desired_name }}
          ONBOOT=yes
          IPADDR={{ hb_iface_ipaddr }}
          PREFIX={{ hb_iface_prefix }}

    - name: Create necessary {{ hb_iface_desired_name }} persistent interface naming rules
      lineinfile:
        path: "{{ net_persistent_rules_file }}"
        create: yes
        line: |
          SUBSYSTEM=="net", ACTION=="add", ATTR{address}=="{{ mac_address }}", ATTR{type}=="1", NAME="{{ final_iface_name }}"
        regexp: 'ATTR{address}=="{{ mac_address }}".*NAME="{{ final_iface_name }}"'
      # Only perform this task if the kernel-assigned interface name is still
      # present. Once the interface has been renamed and new name is in the
      # inventory the task is going to fail because the required lookup is going
      # to fail.
      when:
        - not hb_iface_in_inventory
      notify: Reload udev rules

  notify: Restart network
